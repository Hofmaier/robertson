
\section{Type classes}
\label{sec:typeclasses}

This section will give a short description of the concept type class. It will explain the relation to polymorphism and describe type classes \verb|Functor|, \verb|Applicative| and \verb|Monoid| in more detail as these type classes are important for the example in section \ref{sec:example}.

The concept of a type class was introduced as a construct that supports operator overloading and ad-hoc polymorphism \cite{Wadler}.

A type class is like an interface. It contains the function declarations. A type becomes an instance of a type class when it defines all required functions of the type class. When a type is an instance of a type class, we can make certain assumptions about behavior of the type. In contrary to interfaces, type classes aren't types. A value can have the type of an interface but not of a type class.

The concept of a type class is explained by example with the function \verb|show| from the \verb|Prelude|-Library (\verb|Prelude| is a module and part of the standard). \verb|show| converts a given value of a type \verb|a| into a character string. The type of \verb|show| is

\begin{verbatim}
show :: Show a => a -> String
\end{verbatim}

The \verb|Show a| before the \verb|=>| is a type class constraint. \verb|a| is a type variable. A type that has one more type variables is called polymorphic \cite{hutton}. The signature means that \verb|show| takes something that implements the type class \verb|Show| and returns a string. \verb|Show| is a type class. It's possible to call \verb|show| with different types (e.g \verb|show 1|, \verb|show "hello"|). The compiler will lookup the correct definition for us as long the type of the first parameter is an instance of the type class \verb|Show|.  
Any type that implements \verb|Show| can be converted to a character string. Types in this class are \verb|Bool|, \verb|Char|, \verb|Int|, \verb|Float|, \verb|Double| etc.

The type class \verb|Show| is defined as follows:
\begin{verbatim}
class Show a where
    show :: a -> String
\end{verbatim}
The keyword \verb|class| defines a new type class. \verb|a| is the type variable. It represents the type that implements the type class (e.g. \verb|Int| or \verb|Bool|).

Once we have a type class we are able to create instances of that class. The following listing defines a type \verb|Person|. It has fields for name and email address. 
\begin{verbatim}
data Person = Person { name :: String
                       email :: String
                     }
\end{verbatim}

To make \verb|Person| an instance of \verb|Show| we provide a definition for \verb|show :: Person -> String|

\begin{verbatim}
instance Show Person where
    show (Person name _) = name
\end{verbatim}

There many other useful type classes in the standard library.

\begin{description}
\item[Ord] Types with an order relation implement \verb|Ord|.
\item[Eq] For types that can be equated.
\item[Read] Types that can be convertet from a string.
\end{description}

\subsection{Polymorphism and type classes}
\label{sec:polymorphism}
In this section we will describe relation between type classes and polymorhism.
There are two types of polymorphism in Haskell \cite{Cardelli}. Type classes are used for ad hoc polymorhism.
\begin{description}
\item[Parametric polymorphism] Refers to a type that contains type variables. For example the type of the function \verb|id| is 
\begin{verbatim}
id:: a -> a
\end{verbatim}
The \verb|id| function can be used with any type. There are no constraints. At compile time, the type variables are substituted with a concrete type. For example
\verb|Char -> Char|.
\item[Ad-hoc polymorphism] It's a synonym for function overloading or operator overloading. Polymorphic functions can be applied to values with different types. A polymorphic function uses different definitions (implementations) depending on the types of the arguments. If a type can be converted to a string, it can be given the type class \verb|Show|. The type \verb|Person| has to provide an implementation for the function \verb|show|. Applying \verb|show| to \verb|Person| results in a different behavior then applying \verb|show| to an \verb|Int|.
\end{description}

\subsection{Functor}
\label{sec:functor}

Functor is a type class for types, which can be mapped over. 

The type class declaration is shown in Listing \ref{fig:functordeclaration}.
The \verb|f| in the declaration is a type class constructor. Only type constructor can implement \verb|Functor| (\verb|Maybe|, \verb|[]|).

Functor defines all instances must implement the function \verb|fmap|.
\begin{figure}
  \centering
\begin{verbatim}
class Functor f where
    fmap :: (a -> b) -> f a -> f b
\end{verbatim}
  \caption{Functor type class declaration}
  \label{fig:functordeclaration}
\end{figure}

\verb|fmap| takes any function \verb|a -> b| and a value of type \verb|f a| and returns a value of type \verb|f b|. 
If \verb|f| is of type \verb|Maybe| \verb|Int| and the function of type \verb|Int -> String|, \verb|fmap| returns \verb|Maybe String|. 

\verb|fmap| applies a function to a value without altering its structure or context.

Instances of \verb|Functor| are:

\begin{description}
\item[List] \verb|map| for lists for is the same as \verb|fmap|.
\item[Either] \verb|Either e a| is a container. \verb|fmap| applies a function to \verb|a|.
\end{description}

Instances of the \verb|Functor| type class are expected to exhibit certain kinds of properties. This properties are called the functor laws.
The Haskell Compiler doesn't detect violations of the expected laws. All Functor instances in the standard library obey these laws.

A Functor instance has to satisfy the following laws \cite{Marlow_2010}.

\begin{description}
\item[Law 1] Mapping the identity function over a functor value, will not change the functor value. Formally
\begin{verbatim}
fmap id  ==  id
\end{verbatim}
\item[Law 2] The second law states that it doesn't matter if we compose two functions and them map them over a functor or if we first map one function over the functor and then map the other function. Formally
\begin{verbatim}
fmap (g . h) = fmap g . fmap h
\end{verbatim}
This is the same as \verb|fmap (g . h) = fmap g (fmap h)|
\end{description}

If we can prove that a type satisfies these laws, we can make assumptions about how the the type will act. And we know that \verb|fmap| only maps the function over the functor. It will not change the structure or the context of the functor.

If we know, that a type satisfy the laws, we are able to deduce further properties for our own types. All type class instances in the standard library satisfy the laws \cite{yorgey}.

\begin{figure}
  \centering
\begin{verbatim}
fmap id = id
fmap (g . h) = fmap g . fmap h
\end{verbatim}
  \caption{The Functor laws}
  \label{fig:functorlaws}
\end{figure}

\subsection{Applicative Functor}
\label{sec:applicatives}

Applicative functors are an abstract characterisation of an applicative style of effectful programming \cite{mcbride} \cite{control.applicative}

The \verb|Applicative| type class encapsulates the following idea. What if you have a function wrapped in a \verb|Functor| (e.g \verb|Maybe (Int -> Int -> Int)|) and you want to apply the function to another functor. 

The \verb|Applicative| type class is defined as follows.
\begin{verbatim}
class (Functor f) => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
\end{verbatim}

Applicatives are enhanced functors. They are able to map a function encapsulatet in a functor over another functor.

\begin{figure}
  \centering
     \includegraphics[width=0.9\textwidth]{functor_applicative}
  \caption{Comparison of test, property-based-testing and proof}
  \label{fig:property_validation}
\end{figure}


The following type are instances of the type class \verb|Applicative|

\begin{itemize}
\item Maybe
\item IO
\end{itemize}

\subsection{Monoid}
\label{sec:monoid}

Some types, let's say \verb|a|, have a binary function with the type declaration. 
\begin{verbatim}
f :: a -> a -> a
\end{verbatim}

The type \verb|a| has a value that serves as identity for the given function. For example 1 is the identity for the multiplication. Multiplicaiton with an other numer $x$ results always in $x$.

Several value of type \verb|a| can always be reduces to a single value. It doesn't matter in which order we apply the function, the result is always the same. This is called associativity.

If type \verb|a| has this behavior, it's a monoid and it can be an instance of the \verb|Monoid| type class.

The \verb|Monoid| type class is define as follows:
\begin{verbatim}
class Monoid m where
    mempty :: m
    mappend :: m -> m -> m
    mconcat :: [m] -> m
    mconcat = foldr mappend mempty
\end{verbatim}

The \verb|Monoid| type class is define in \verb|Data.Monoid| \cite{monoid}. 

From the type class definition we see that concrete type can be made instances of \verb|Monoid|. 

\verb|mempty| return the identity value. The binary function is \verb|mappend|. It takes to values of the same type and returns another value of that type. \verb|mconcat| takes a list of monoids and reduces them \verb|mappend| to a single value, applying mappend. It has a default implementation.

When making monoid instances, we need to make sure that \verb|mempty| acts like the identity with respect to the \verb|mappend| function and \verb|mappend| must be assocative. There are three monoid laws

\begin{enumerate}
\item \verb|mappend mempty x = x|
\item \verb|mappend x mempty = x|
\item \verb|(x `mappend y) `mappend z = x `mappend (y `mappend z)|
\end{enumerate}

The following Haskell types are \verb|Monoid| instances
\begin{description}
\item[List] The empty list \verb|[]| and \verb|++| (concatenation) form a monoid.
\item[Product and Sum] Numbers can be monoid with respect to multiplication or addidion. There are two monoid instances for \verb|Num|.
\item[Maybe] Can also be an instance of \verb|Monoid|.
\end{description}

An interesting property of the \verb|Applicative| type class with respect to the monoid type class is, if \verb|f| is an \verb|Applicative| and \verb|m| is a \verb|Monoid|, \verb|f b| is also a \verb|Monoid|. This is because we can make an \verb|Applicative| with the given property an instance of \verb|Monoid|.
\begin{program}
\begin{verbatim}
instance (Applicative f, Monoid b) => Monoid (f b) where
    mempty = pure mempty

    mappend = liftA2 mappend
\end{verbatim}
\label{lst:applicative2monoid}
\caption{Applicative property}
\end{program}

As \verb|f| is an applicative, it implements \verb|pure|. The \verb|mempty| function returns the identity value of \verb|b| in a default context. \verb|liftA2| encapsulates the \verb|mappend| function in a applicative functor. It's possible to prove this property with equational reasoning.
