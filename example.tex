\section{Example proof for Monoid Laws}
\label{sec:example}
In this example we use equational reasoning (see section \ref{sec:equationalreasoning} to prove the monoid laws (see section \ref{sec:monoid}) for a new type.
The following example is taken from a blogpost of Gabriel Gonzales \cite{gonzales14}. 

Suppose we want to build a plugin system. A plugin is a \verb|IO| action, that takes a \verb|Char| value runs does some work with it (e.g. log to a file, potentially with side effect). We demand the following requirements:
\begin{itemize}
\item We want to be able to add an arbritrary number of plugins.
\item The plugins should be composable.
\item The order we add the plugins must not matter.
\end{itemize}

A monoid instance satisies all listed requirements. We could use the \verb|<>| operator to compose several plugins. Hence,  if we can prove that the plugins satisfy the monoid laws, we can combine them, using the monoid function \verb|mappend| and we are able to add plugins without concerning about the order of evaluation. In addition they are easier to use because the will behave as expected.

Listing \ref{lst:plugin} show use of the plugin. The \verb|logto| function is a plugin. The program will read a character \verb|c| from the command line and apply the given plugin to \verb|c|.

\begin{program}
\begin{verbatim}
main = do
    handleChar <- logto
    c <- getChar
    handleChar c
\end{verbatim}
\label{lst:plugin}
\caption{main for plugin system}
\end{program}

To append additional plugins, e.g. \verb|print2stdout|, we compose \verb|logto| with the \verb|<>|.
\begin{verbatim}
handleChar <- logto <> print2stdout
\end{verbatim}
The \verb|logTo| function is shown in Listing \ref{lst:logto}. Its of type \verb|IO(Char->IO())|. 

\begin{program}
\begin{verbatim}
logTo :: IO ( Char -> IO ())
logTo = do
    handle <- openFile "log.txt" WriteMode
    return (hPutChar handle)
\end{verbatim}
\label{lst:logto}
\caption{main for plugin system}
\end{program}

The plugins are of type \verb|IO ( Char -> IO ())|. We have to  prove that the monoid laws from section \ref{sec:monoid} hold for the type \verb|IO ( Char -> IO ())|.
As mentioned in listing \ref{lst:applicative2monoid}, applicative can be a monoid if the encapsulated type is a monoid. To prove that \verb|IO ( Char -> IO ())| is a monoid, the type \verb|IO| has to be an applicative and \verb|Char -> IO ()| has to be a monoid. Hence \verb|Char -> IO ()| has to be a monoid.

The type \verb|Monoid b => (a -> b)| is monoid instance implemented by the standard library \cite{monoid}, hence \verb|Char -> IO ()| is a monoid if \verb|IO ()| is a monoid

According to property \ref{lst:applicative2monoid} \verb|IO ()| is a monoid if \verb|()| is a monoid.

Here is an overview of all the steps of the proof:
\begin{enumerate}
\item prove that property from \ref{lst:applicative2monoid} holds.
\item show that  \verb|IO ( Char -> IO ())| is a monoid.
\item show that \verb|Char -> IO ()| is a monoid
\item show that \verb|IO ()| is a monoid
\item show that \verb|()| is a monoid
\end{enumerate}

We show the required properties in reversed order.

\begin{etaremune}
\item The standard library provides a monoid instance for \verb|()| \cite{monoid}. In this article we will believe the farytale of abstraction and assume that the implemention of the standard library satisfies the monoid laws.
\item \verb|IO()| is a monoid, because \verb|IO| is an applicative and \verb|()| is a monoid if property from listing \ref{lst:applicative2monoid} holds.
\item Functions (functions have type \verb|(->) r|) are an instance of \verb|Applicative|. The applicative instance is defined as follows:
\begin{verbatim}
instance Monoid b => Monoid (a -> b) where
    mempty = pure mempty

    mappend = liftA2 mappend
\end{verbatim}
 \verb|Char->IO()| is a monoid because \verb|(->)Char| is a applicative and \verb|IO ()| is a monoid if property from listing \ref{lst:applicative2monoid} holds.
\item \verb|IO(Char->IO())| is a monoid because \verb|IO| is an applicative and \verb|Char->IO()| is a monoid if property from listing \ref{lst:applicative2monoid} holds.
\item  We can prove the property from \ref{lst:applicative2monoid} with equational reasoning.
\end{etaremune} 

The left identity law of the monoid type class demands that:
\begin{verbatim}
mappend mempty x = x
\end{verbatim}

\begin{verbatim}
mappend mempty x

-- mappend = liftA2 mappend  
= liftA2 mappend mempty x

-- mempty = pure mempty   
= liftA2 mappend (pure mempty) x

-- liftA2 f x y = (pure f <*> x) <*> y
= (pure mappend <*> pure mempty) <*> x

-- Applicative law: pure f <*> pure x = pure (f x)
= pure (mappend mempty) <*> x

-- transform mappend mempty to lambda
= pure (\a -> mappend mempty a) <*> x

-- mappend mempty x = x
= pure (\a -> a) <*> x

-- id = \x -> x
= pure id <*> x

-- Applicative law: pure id <*> v = v
= x
\end{verbatim}
