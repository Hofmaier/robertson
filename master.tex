\documentclass[twoside, a4paper]{article}
\usepackage{amsmath}
\usepackage{float}
\usepackage{graphicx}
\usepackage{url}
\usepackage{etaremune}
\newfloat{program}{thp}{lop}
\floatname{program}{Listing}
\author{Lukas Hofmaier}
\title{Type class laws}

\begin{document}
\maketitle
\tableofcontents

\input{introduction}
\input{typeclass}
\input{equational_reasoning}

\subsection{Example proof for Monoid Laws}
\label{sec:example}

The following example is taken from a blogpost of Gabriel Gonzales \cite{gonzales14}. 

Suppose we want to build a plugin system, that uses monoids to add additional functionality to system. If we can prove that the plugins satisfy the monoid laws, we can combine them, using the monoid function \verb|<>| and we can apply them without concerning about the order of evaluation. In addition they will behave as expected. 

Listing \ref{lst:plugin} show use of the plugin. The \verb|logto| function is a plugin. The program will read a character \verb|c| from the command line and apply the given plugin to \verb|c|.

\begin{program}
\begin{verbatim}
main = do
    handleChar <- logto
    c <- getChar
    handleChar c
\end{verbatim}
\label{lst:plugin}
\caption{main for plugin system}
\end{program}

The \verb|logTo| function is shown in Listing \ref{lst:logto}. Its of type \verb|IO(Char->IO())|. 

\begin{program}
\begin{verbatim}
logTo :: IO ( Char -> IO ())
logTo = do
    handle <- openFile "log.txt" WriteMode
    return (hPutChar handle)
\end{verbatim}
\label{lst:logto}
\caption{main for plugin system}
\end{program}

The plugins are of type \verb|IO ( Char -> IO ())|. We have to  prove that the monoid laws from section \ref{sec:monoid} hold for the type \verb|IO ( Char -> IO ())|.
As mentioned in listing \ref{lst:applicative2monoid}, applicative can be a monoid if the encapsulated type is a monoid. To prove that \verb|IO ( Char -> IO ())| is a monoid, the type \verb|IO| has to be an applicative and \verb|Char -> IO ()| has to be a monoid. Hence \verb|Char -> IO ()| has to be a monoid.

The type \verb|Monoid b => (a -> b)| is monoid instance implemented by the standard library \cite{monoid}, hence \verb|Char -> IO ()| is a monoid if \verb|IO ()| is a monoid

According to property \ref{lst:applicative2monoid} \verb|IO ()| is a monoid if \verb|()| is a monoid.

Here is an overview of all the steps of the proof:
\begin{enumerate}
\item prove that property from \ref{lst:applicative2monoid} holds.
\item show that  \verb|IO ( Char -> IO ())| is a monoid.
\item show that \verb|Char -> IO ()| is a monoid
\item show that \verb|IO ()| is a monoid
\item show that \verb|()| is a monoid
\end{enumerate}

We show the required properties in reversed order.

\begin{etaremune}
\item The standard library provides a monoid instance for \verb|()| \cite{monoid}. In this article we will believe the farytale of abstraction and assume that the implemention of the standard library satisfies the monoid laws.
\item \verb|IO()| is a monoid, because \verb|IO| is an applicative and \verb|()| is a monoid if property from listing \ref{lst:applicative2monoid} holds.
\item Functions (functions have type \verb|(->) r|) are an instance of \verb|Applicative|. The applicative instance is defined as follows:
\begin{verbatim}
instance Monoid b => Monoid (a -> b) where
    mempty = pure mempty

    mappend = liftA2 mappend
\end{verbatim}
 \verb|Char->IO()| is a monoid because \verb|(->)Char| is a applicative and \verb|IO ()| is a monoid if property from listing \ref{lst:applicative2monoid} holds.
\item \verb|IO(Char->IO())| is a monoid because \verb|IO| is an applicative and \verb|Char->IO()| is a monoid if property from listing \ref{lst:applicative2monoid} holds.
\item  We can prove the property from \ref{lst:applicative2monoid} with equational reasoning.
\end{etaremune} 

The left identity law of the monoid type class demands that:
\begin{verbatim}
mappend mempty x = x
\end{verbatim}

\begin{verbatim}
mappend mempty x

-- mappend = liftA2 mappend  
= liftA2 mappend mempty x

-- mempty = pure mempty   
= liftA2 mappend (pure mempty) x

-- liftA2 f x y = (pure f <*> x) <*> y
= (pure mappend <*> pure mempty) <*> x

-- Applicative law: pure f <*> pure x = pure (f x)
= pure (mappend mempty) <*> x

-- transform mappend mempty to lambda
= pure (\a -> mappend mempty a) <*> x

-- mappend mempty x = x
= pure (\a -> a) <*> x

-- id = \x -> x
= pure id <*> x

-- Applicative law: pure id <*> v = v
= x
\end{verbatim}

\section{Pipes: A real world example}
\label{sec:pipes}

Pipes is a streaming library for Haskell. It was build with the following requirements \cite{gonzales13}.
\begin{description}
\item[Effects] Streams has to be effectful
\item[Streaming] Processing in constant memory
\item[Composability] Modules have to be composable
\end{description}

Pipes uses the type class \verb|Category| too keep the API simple and easy to use.

This article will descipe a part of the library with an example.

First we need a input stream, that emits values. Input streams are have the type 
\verb|Producer a m ()|.
Listing \ref{lst:simpleproducer} show a simple Producer. It emits the integers 1,2 and 3. It is also possible to create producers for effectful streams. We use the simple producer from Listing \ref{lst:simpleproducer} for simplicity reasons.

\begin{program}
\begin{verbatim}
produceints123 :: Producer Int IO ()
produceints123 = each [1,2,3]
\end{verbatim}
\caption{Simple Producer}
\label{lst:simpleproducer}
\end{program}

Pipes provide the function \verb|for| to consume a producer. 
\verb|for| \verb|producer| \verb|body| loops over the \verb|producer| and applies a the transformation defined in \verb|body| to every element yielded by the producer. If the body is of type \verb|Effect| it return an \verb|Effect|. If body is of type \verb|Producer| a \verb|Producer| is returned. The type declaration of \verb|for| 
\begin{program}
\begin{verbatim}
for::Monad m=>
Producer b m r
-> (b -> Producer c m ())
-> Producer c m r
\end{verbatim}
\caption{type of for}
\end{program}

A value for the body, could be function, that takes \verb|Int| and returns producer \verb|Producer a IO ()|. Hence the type declarion is \verb|Int -> Producer a IO ()|. We implement a body, that prints the integers to the standard input (strictly speaking this value is an effect of type \verb|Effect Int ()|. But \verb|Effect Int ()| is of type \verb|Producer Int IO () |).

\begin{program}
\begin{verbatim}
print2stdout:: Int -> Effect IO ()
print2stdout x = (lift . putStrLn . show ) x
\end{verbatim}
\caption{Definition of an effect, that prints to stdout}
\label{lst:stdouteffect}
\end{program}

With the producer and the body we can define a \verb|Effect IO ()|
\begin{verbatim}
effect :: Effect IO ()
effect = for produceints123 print2stdout
\end{verbatim}

Because the \verb|body| and of \verb|for| can be of type \verb|a -> Producer|, and the type of the return value is \verb|Producer|, it's possible to interleave several Producers.

If we want to duplicate all element we write another body
\begin{verbatim}
duplicate :: Int -> Producer Int IO ()
duplicate x = yield x >> yield x 
\end{verbatim}

We use \verb|for| to create a another producer. \verb|composed_producer| is a composition of \verb|produceints123| and \verb|duplicate|.
\begin{verbatim}
composed_producer :: Producer Int IO ()
composed_producer = for produceints123 duplicate
\end{verbatim}

To compose \verb|composed_producer| with our \verb|print2stdout| effect, we apply the \verb|for| function

\begin{verbatim}
effect2 :: Effect IO ()
effect2 = for composed_producer print2stdout
\end{verbatim}

In order to compose producers, the pipe library provides the \verb|~>| function. \verb|~>| is defined as follows:
\begin{verbatim}
(f ~> g) x = for (f x) g
\end{verbatim}

Hence we can write compose a body for \verb|for| like this:
\begin{verbatim}
composed_with_yield :: Int -> Effect IO ()
composed_with_yield = duplicate ~> print2stdout
\end{verbatim}

Gabriel Gonzales proved that the \verb|~>| operator is associativ. It has the associativity property.

\begin{verbatim}
 -- Associativity
 (f ~> g) ~> h = f ~> (g ~> h)
\end{verbatim}

Because the \verb|~>| operator is associativ, it doesnt matter in witch order the body is composed. The expected behavior is defined in term of cateory laws. It's possible to prove that the specified laws hold.

\section{Function composition}

\label{sec:functioncomposition}

Function composition in mathematics is defined as

\begin{equation}
  \label{eq:functioncomposition}
  (f \circ g)(x) = f(g(x))
\end{equation}

Haskell functions can be compose with the \verb|.| function.

\begin{figure}
  \centering
\begin{verbatim}
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \x -> f (g x)
\end{verbatim}
  \caption{. function}
  \label{fig:compositionfunction}
\end{figure}

Function composition allows us to create a function by composing it with many small functions. 

Functions in Haskell form a category in category theory. They satisfy the category laws.
\begin{description}
\item[Associativity law] 
\item[Left/Right Identity law] 
\end{description}

\bibliographystyle{plain}
\bibliography{a}
\end{document}