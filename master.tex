\documentclass[twoside, a4paper]{article}
\usepackage{amsmath}
\usepackage{float}
\usepackage{graphicx}
\usepackage{url}
\usepackage{etaremune}
\newfloat{program}{thp}{lop}
\floatname{program}{Listing}
\author{Lukas Hofmaier}
\title{Type class laws}

\begin{document}
\maketitle
\tableofcontents

\section{Introduction}
\label{sec:intro}

Type classes are a concept to describe behavior. In addition, they are excpectet to exhibit certain properties. This properties are called laws. 
Laws allow the programmer to make assumption about the behavior and reason about the code. We can rely on certain properties like associativity for example.

The compiler doesn't verifiy if a given property holds. We have to verify the laws with formal verfification. Formal verification is a tool use for software application with the aim of providing a high reliability. The first formally verified micro kernel, seL4 was verified using Haskell. Haskell was used because programmers can reason about the source code \cite{Klein09}. Correctness is specified in form of equations. The source code must satisfy this equations. Programmers can use equational reasoning to verify the correctness of these equations.

Purely functional programming languages are easier to reason about as imperative or object-oriented languages. All examples in this articel a written in Haskell.

In this article we first describe type classes with a few examples. Then we show that eqational reasoning can be used to verify properties of a haskell program. In a example we will prove that the monoid laws holds for new type. The next section shows that equational reasoning is used in a common library like pipes.

\input{typeclass}

\section{Equational Reasoning}
\label{sec:equationalreasoning}

Some programmers care about the correctness of their software. It's hard to write a correct program at the first attempt. 
Hence, verification of a program improves the reliability of the software. Verification is process of checking if the software does the specification demands. This means that the specification is required. In the case of implementing the type classes of section \ref{sec:typeclasses}, the specification is defined in form of laws. The following section will describe the verification method equational reasoning. We will use equational reason in section \ref{sec:example} to show that the monoid laws hold for a given type.

There are several ways to check the behavior of a program. 
We will describe the difference with a simple example.
If we apply \verb|reverse| to times on the same list \verb|xs| we get back the original list \verb|xs|. \verb|reverse| is the inverse of \verb|reverse|. 

\begin{equation}
  \label{eq:reverse_prop}
\text{reverse} (\text{reverse} xs) == xs  
\end{equation}
This Boolean expression formulates a desired property. 

\begin{description}
\item[Testing] Run the program with selected input and check if it behaves as expected. Listing \ref{lst:testfunction} gives a test function of the property \ref{eq:reverse_prop} for the input \verb|[1,2,3]|.
  \label{fig:test}
\begin{program}
\begin{verbatim}
input = [1,2,3]

test_reverse :: [Int] -> Bool
test_reverse xs = reverse (reverse xs) == xs
\end{verbatim}
\caption{Test-Function}
\label{lst:testfunction}
\end{program}

In order to check if the property \ref{eq:reverse_prop} for the given input holds, we have to run the program.
 An advantage of this method is, that the programmer hasn't to define general properties. It's easier to think about a concrete input and the corresponding output.

\item[Property-based testing] The input for the test program is generated randomly. The test are executed by a tool (e.g. Quickcheck)
\item[Proof] A Proof can show that a property holds in all circumstances. With the definition of the function \verb|reverse| it's possible to proof that property \ref{eq:reverse_prop} always holds. 
\end{description}

\begin{figure}
  \centering
     \includegraphics[width=0.9\textwidth]{comp}
  \caption{Comparison of test, property-based-testing and proof}
  \label{fig:property_validation}
\end{figure}

Equational reasoning isn't a method only used in programming. Equational reasoning is the process of substituting expressions. With equational reasoning we are able to show that certain properties hold.
For example, it's possible to show that

\begin{equation}
  \label{eq:sum}
  (x+a)(x+b) = x^2 + (a+b)x+ab
\end{equation}

is true. To show the equality we have to only have to substitute the expression on the left-hand side with the help of the basic algebraic properties of numbers (commutative, associative, distributive) \cite{hutton}.

A function definition in Haskell means that we can substitute the left-hand side. Hence, we can use reasoning about a Haskell program in the same way, we reason about mathematical expressions. With equational reasoning it's possible to deduce properties from definitions.

For example, it's possible to show that 
\begin{verbatim}
length [x] == 1
\end{verbatim}
no matter what \verb|x| is.

This article will only describe proofs with programs, which halts. An evaluation can go on forever.
\begin{verbatim}
f x = 1 + f x
\end{verbatim}

The value of the expression is undefined. The proofs in this article hold only for defined expressions and finite lists..

Equational reasoning is use-full because
\begin{itemize}
\item it allows to verify properties of a program.
\item can be used to eliminate expensive function call while preserving behavior
\end{itemize}

\subsection{Proof by structural induction}
\label{sec:induction}

The technique proof by induction is often used to reason about programs that involve recursion. The principle of induction states that it is sufficient to prove a property $p$ for the base case and that $p$ is preserved by the inductive case.

Proof by induction is similar to write a recursive function. Recursive functions use a base case (e.g. \verb|[]|, 0). 
If we use structural induction we proof the base case.

A recursive function definition we define \verb|f (x:xs)| and use \verb|f x| in the right-hand side. In the proof we show that $p(n+1)$ with the assumption $p(n)$.

The pattern for structural induction for proofing a property can be use for list or algebraic data types with a recursive constructor (e.g. Tree).

We use induction to prove the following property
\begin{equation}
  \label{eq:lengthprop}
  \text{length (xs ++ ys)} = \text{(length xs) ++ (length ys)}
\end{equation}

The Prelude functions \verb|length| and \verb|(++)| are defined as follows:
\begin{program}
\begin{verbatim}
length [] = 0
length (x:xs) = 1 + length 
\end{verbatim}
\caption{Definition length function}
\label{lst:lengthdefinition}  
\end{program}

\begin{program}
\begin{verbatim}
[] ++ xs = xs
(x:xs) ++ ys = x:(xs++ys)
\end{verbatim}
\caption{Definition: ++ - function}
\label{lst:catdefinition}  
\end{program}

First we have to show that property \ref{eq:lengthprop} holds for the base case. The base case, in this example, are the arguments \verb|[]| and a arbitrary list for \verb|ys|. It isn't necessary to replace \verb|ys| because, the definition of \verb|++| uses recursion over \verb|xs|. \verb|ys| will always be the same list.
In order to check if property \ref{eq:lengthprop} holds for the base case, we replace \verb|xs| with  \verb|[]|, leading to

\begin{program}
\begin{verbatim}
length ([] ++ ys) = length [] + length ys
\end{verbatim}
\caption{Base case}
\label{lst:equality1}
\end{program}

We will evaluate the expression on the left-hand side and the right and side separately.

The left-hand side evaluates to
\begin{program}
\begin{verbatim}
length ([] ++ ys) -- apply ++
length ys
\end{verbatim}
\end{program}

The right-hand side evaluates to 
\begin{program}
\begin{verbatim}
length [] + length ys     -- apply length []
0 + length ys
length ys
\end{verbatim}
\end{program}

Both sides of the function definition in Listing \ref{lst:equality1} are equal. Hence, property \ref{eq:lengthprop} holds for the empty list, our base case.

Now we have to prove the induction step. We have to prove that
\begin{equation}
  \label{eq:induction}
    \text{length ((x:xs) ++ ys)} = \text{(length (x:xs)) ++ (length ys)}
\end{equation}

with the assumption (induction hypothesis)
\begin{equation}
  \label{eq:induction_hypothesis}
      \text{length (xs ++ ys)} = \text{(length xs) ++ (length ys)}
\end{equation}

Again, we evaluate the the left hand side of equation \ref{eq:induction}.

\begin{program}
\begin{verbatim}
length ((x:xs) ++ ys)}     --apply definition of ++
length (x:(xs ++ ys))      --apply definition of length
1 + length (xs ++ ys)      --use induction hypothesis
1 + length xs + length ys
\end{verbatim}
\end{program}

If we evaluate the right-hand side of the induction step in equation  \ref{eq:induction} we get:
\begin{program}
\begin{verbatim}
length (x:xs) + length ys    -- apply definition of length
1 + length xs + length ys
\end{verbatim}
\end{program}

The last listing shows, that the equation \ref{eq:induction} follows from the induction hypothesis in equation \ref{eq:induction_hypothesis}. This completes the induction step and therefore the proof itself.

\subsection{Example proof for Monoid Laws}
\label{sec:example}

The following example is taken from a blogpost of Gabriel Gonzales \cite{gonzales14}. 

Suppose we want to build a plugin system, that uses monoids to add additional functionality to system. If we can prove that the plugins satisfy the monoid laws, we can combine them, using the monoid function \verb|<>| and we can apply them without concerning about the order of evaluation. In addition they will behave as expected. 

Listing \ref{lst:plugin} show use of the plugin. The \verb|logto| function is a plugin. The program will read a character \verb|c| from the command line and apply the given plugin to \verb|c|.

\begin{program}
\begin{verbatim}
main = do
    handleChar <- logto
    c <- getChar
    handleChar c
\end{verbatim}
\label{lst:plugin}
\caption{main for plugin system}
\end{program}

The \verb|logTo| function is shown in Listing \ref{lst:logto}. Its of type \verb|IO(Char->IO())|. 

\begin{program}
\begin{verbatim}
logTo :: IO ( Char -> IO ())
logTo = do
    handle <- openFile "log.txt" WriteMode
    return (hPutChar handle)
\end{verbatim}
\label{lst:logto}
\caption{main for plugin system}
\end{program}

The plugins are of type \verb|IO ( Char -> IO ())|. We have to  prove that the monoid laws from section \ref{sec:monoid} hold for the type \verb|IO ( Char -> IO ())|.
As mentioned in listing \ref{lst:applicative2monoid}, applicative can be a monoid if the encapsulated type is a monoid. To prove that \verb|IO ( Char -> IO ())| is a monoid, the type \verb|IO| has to be an applicative and \verb|Char -> IO ()| has to be a monoid. Hence \verb|Char -> IO ()| has to be a monoid.

The type \verb|Monoid b => (a -> b)| is monoid instance implemented by the standard library \cite{monoid}, hence \verb|Char -> IO ()| is a monoid if \verb|IO ()| is a monoid

According to property \ref{lst:applicative2monoid} \verb|IO ()| is a monoid if \verb|()| is a monoid.

Here is an overview of all the steps of the proof:
\begin{enumerate}
\item prove that property from \ref{lst:applicative2monoid} holds.
\item show that  \verb|IO ( Char -> IO ())| is a monoid.
\item show that \verb|Char -> IO ()| is a monoid
\item show that \verb|IO ()| is a monoid
\item show that \verb|()| is a monoid
\end{enumerate}

We show the required properties in reversed order.

\begin{etaremune}
\item The standard library provides a monoid instance for \verb|()| \cite{monoid}. In this article we will believe the farytale of abstraction and assume that the implemention of the standard library satisfies the monoid laws.
\item \verb|IO()| is a monoid, because \verb|IO| is an applicative and \verb|()| is a monoid if property from listing \ref{lst:applicative2monoid} holds.
\item Functions (functions have type \verb|(->) r|) are an instance of \verb|Applicative|. The applicative instance is defined as follows:
\begin{verbatim}
instance Monoid b => Monoid (a -> b) where
    mempty = pure mempty

    mappend = liftA2 mappend
\end{verbatim}
 \verb|Char->IO()| is a monoid because \verb|(->)Char| is a applicative and \verb|IO ()| is a monoid if property from listing \ref{lst:applicative2monoid} holds.
\item \verb|IO(Char->IO())| is a monoid because \verb|IO| is an applicative and \verb|Char->IO()| is a monoid if property from listing \ref{lst:applicative2monoid} holds.
\item  We can prove the property from \ref{lst:applicative2monoid} with equational reasoning.
\end{etaremune} 

The left identity law of the monoid type class demands that:
\begin{verbatim}
mappend mempty x = x
\end{verbatim}

\begin{verbatim}
mappend mempty x

-- mappend = liftA2 mappend  
= liftA2 mappend mempty x

-- mempty = pure mempty   
= liftA2 mappend (pure mempty) x

-- liftA2 f x y = (pure f <*> x) <*> y
= (pure mappend <*> pure mempty) <*> x

-- Applicative law: pure f <*> pure x = pure (f x)
= pure (mappend mempty) <*> x

-- transform mappend mempty to lambda
= pure (\a -> mappend mempty a) <*> x

-- mappend mempty x = x
= pure (\a -> a) <*> x

-- id = \x -> x
= pure id <*> x

-- Applicative law: pure id <*> v = v
= x
\end{verbatim}

\section{Pipes: A real world example}
\label{sec:pipes}

Pipes is a streaming library for Haskell. It was build with the following requirements \cite{gonzales13}.
\begin{description}
\item[Effects] Streams has to be effectful
\item[Streaming] Processing in constant memory
\item[Composability] Modules have to be composable
\end{description}

Pipes uses the type class \verb|Category| too keep the API simple and easy to use.

This article will descipe a part of the library with an example.

First we need a input stream, that emits values. Input streams are have the type 
\verb|Producer a m ()|.
Listing \ref{lst:simpleproducer} show a simple Producer. It emits the integers 1,2 and 3. It is also possible to create producers for effectful streams. We use the simple producer from Listing \ref{lst:simpleproducer} for simplicity reasons.

\begin{program}
\begin{verbatim}
produceints123 :: Producer Int IO ()
produceints123 = each [1,2,3]
\end{verbatim}
\caption{Simple Producer}
\label{lst:simpleproducer}
\end{program}

Pipes provide the function \verb|for| to consume a producer. 
\verb|for| \verb|producer| \verb|body| loops over the \verb|producer| and applies a the transformation defined in \verb|body| to every element yielded by the producer. If the body is of type \verb|Effect| it return an \verb|Effect|. If body is of type \verb|Producer| a \verb|Producer| is returned. The type declaration of \verb|for| 
\begin{program}
\begin{verbatim}
for::Monad m=>
Producer b m r
-> (b -> Producer c m ())
-> Producer c m r
\end{verbatim}
\caption{type of for}
\end{program}

A value for the body, could be function, that takes \verb|Int| and returns producer \verb|Producer a IO ()|. Hence the type declarion is \verb|Int -> Producer a IO ()|. We implement a body, that prints the integers to the standard input (strictly speaking this value is an effect of type \verb|Effect Int ()|. But \verb|Effect Int ()| is of type \verb|Producer Int IO () |).

\begin{program}
\begin{verbatim}
print2stdout:: Int -> Effect IO ()
print2stdout x = (lift . putStrLn . show ) x
\end{verbatim}
\caption{Definition of an effect, that prints to stdout}
\label{lst:stdouteffect}
\end{program}

With the producer and the body we can define a \verb|Effect IO ()|
\begin{verbatim}
effect :: Effect IO ()
effect = for produceints123 print2stdout
\end{verbatim}

Because the \verb|body| and of \verb|for| can be of type \verb|a -> Producer|, and the type of the return value is \verb|Producer|, it's possible to interleave several Producers.

If we want to duplicate all element we write another body
\begin{verbatim}
duplicate :: Int -> Producer Int IO ()
duplicate x = yield x >> yield x 
\end{verbatim}

We use \verb|for| to create a another producer. \verb|composed_producer| is a composition of \verb|produceints123| and \verb|duplicate|.
\begin{verbatim}
composed_producer :: Producer Int IO ()
composed_producer = for produceints123 duplicate
\end{verbatim}

To compose \verb|composed_producer| with our \verb|print2stdout| effect, we apply the \verb|for| function

\begin{verbatim}
effect2 :: Effect IO ()
effect2 = for composed_producer print2stdout
\end{verbatim}

In order to compose producers, the pipe library provides the \verb|~>| function. \verb|~>| is defined as follows:
\begin{verbatim}
(f ~> g) x = for (f x) g
\end{verbatim}

Hence we can write compose a body for \verb|for| like this:
\begin{verbatim}
composed_with_yield :: Int -> Effect IO ()
composed_with_yield = duplicate ~> print2stdout
\end{verbatim}

Gabriel Gonzales proved that the \verb|~>| operator is associativ. It has the associativity property.

\begin{verbatim}
 -- Associativity
 (f ~> g) ~> h = f ~> (g ~> h)
\end{verbatim}

Because the \verb|~>| operator is associativ, it doesnt matter in witch order the body is composed. The expected behavior is defined in term of cateory laws. It's possible to prove that the specified laws hold.

\section{Function composition}

\label{sec:functioncomposition}

Function composition in mathematics is defined as

\begin{equation}
  \label{eq:functioncomposition}
  (f \circ g)(x) = f(g(x))
\end{equation}

Haskell functions can be compose with the \verb|.| function.

\begin{figure}
  \centering
\begin{verbatim}
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \x -> f (g x)
\end{verbatim}
  \caption{. function}
  \label{fig:compositionfunction}
\end{figure}

Function composition allows us to create a function by composing it with many small functions. 

Functions in Haskell form a category in category theory. They satisfy the category laws.
\begin{description}
\item[Associativity law] 
\item[Left/Right Identity law] 
\end{description}

\bibliographystyle{plain}
\bibliography{a}
\end{document}