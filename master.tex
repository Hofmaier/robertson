\documentclass[twoside, a4paper, 12pt]{article}
\usepackage{amsmath}
\usepackage{float}
\usepackage{graphicx}
\usepackage{url}
\newfloat{program}{thp}{lop}
\floatname{program}{Listing}
\author{Lukas Hofmaier}
\title{Type class laws}

\begin{document}
\maketitle
\tableofcontents

\section{Introduction}
\label{sec:intro}

Formal verification is a tool use for software application with the aim of providing a high reliability. The first formally verified micro kernel, seL4 was verified using Haskell. Haskell was used because programmers can reason about the source code \cite{Klein09}. Correctness is specified in form of equations. The source code must satisfy this equations. Programmers can use equational reasoning to verify the correctness of these equations.
Purely functional programming languages are easier to reason about as imperative or object-oriented languages.

\section{Type classes}
\label{sec:typeclasses}

A type class is like an interface. It defines behavior of a type. A type becomes an instance of a type class if it implements the functions of the type class. When a type class implements a type class, the type provides the functions, which the type class defines.
The concept of a type class is explained with the function \verb|show| from the \verb|Prelude|-Library. \verb|show| converts a given type into a character string.
\begin{verbatim}
show :: Show a => a -> String
\end{verbatim}
The \verb|Show a| before the \verb|=>| is a class constraint. \verb|a| is a type variable. The signature means that \verb|show| takes something that implements the type class \verb|Show| and returns a string. \verb|Show| is a type class. 
Any type that implements \verb|Show| can be converted to a character string. Types in this class are \verb|Bool|, \verb|Char|, \verb|Int|, \verb|Float|, \verb|Double| etc.

A type class is defined as follows: For example \verb|Show|:
\begin{verbatim}
class Show a where
    show :: a -> String
\end{verbatim}
The keyword \verb|class| defines a new type class. \verb|a| is the type variable. It can be replaced with the type that implements the type class.

Once we have a class we make types instances of that class. If we have a type \verb|Person| with an name and an email address:
\begin{verbatim}
data Person = Person { name :: String
                       email :: String
                     }
\end{verbatim}

To print out a person the type \verb|Person| has to be an instance of \verb|Show|.

\begin{verbatim}
instance Show Person where
    show (Person name _) = name
\end{verbatim}

There many other useful type classes in the standard library.

\begin{description}
\item[Ord] Types with an order relation implement \verb|Ord|.
\item[Eq] For types that can be equated.
\item[Read] Types that can be convertet from a string.
\end{description}

\subsection{Polymorphism and type classes}
\label{sec:polymorphism}

There are two types of polymorphism in Haskell \cite{Cardelli}.
\begin{description}
\item[Parametric polymorphism] Refers to a type that contains type variable. For example the type of the function \verb|id| is 
\begin{verbatim}
id:: a -> a
\end{verbatim}
The \verb|id| function can be used with any type. There are no constraints. At compile time the type variable are substituted with a concrete type. For example
\verb|Char -> Char|.
\item[Ad-hoc polymorphism] It's a synonym for function overloading or operator overloading. Polymorphic functions can be applied to types with different types. A polymorphic function uses different definitions (implementations) depending on the types of the arguments. If a type can be converted to a string, it can be given the type class \verb|Show|. The type \verb|Person| has to implement \verb|show|. Applying \verb|show| to \verb|Person| results in a different behavior then applying \verb|show| to an \verb|Int|.
\end{description}

\subsection{Functor}
\label{sec:functor}

Functor is a type class for types, which can be mapped over. 

The type class declaration is shown in Listing \ref{fig:functordeclaration}.
The \verb|f| in the declaration is a type class constructor. Only type constructor can implement \verb|Functor| (\verb|Maybe|, \verb|[]|).

Functor defines all instances must implement the function \verb|fmap|.
\begin{figure}
  \centering
\begin{verbatim}
class Functor f where
    fmap :: (a -> b) -> f a -> f b
\end{verbatim}
  \caption{Functor type class declaration}
  \label{fig:functordeclaration}
\end{figure}

\verb|fmap| takes any function \verb|a -> b| and a value of type \verb|f a| and returns a value of type \verb|f b|. 
If \verb|f| is of type \verb|Maybe| \verb|Int| and the function of type \verb|Int -> String|, \verb|fmap| returns \verb|Maybe String|. 

\verb|fmap| applies a function to a value without altering its structure or context.

Instances of \verb|Functor| are:

\begin{description}
\item[List] \verb|map| for lists for is the same as \verb|fmap|.
\item[Either] \verb|Either e a| is a container. \verb|fmap| applies a function to \verb|a|.
\end{description}

Instances of the \verb|Functor| type class are expected to exhibit certain kinds of properties. This properties are called the functor laws.
The Haskell Compiler doesn't detect violations of the expected laws. All Functor instances in the standard library obey these laws.

A Functor instance has to satisfy the following laws \cite{Marlow_2010}.

\begin{description}
\item[Law 1] Mapping the identity function over a functor value, will not change the functor value. Formally
\begin{verbatim}
fmap id  ==  id
\end{verbatim}
\item[Law 2] The second law states that it doesn't matter if we compose two functions and them map them over a functor or if we first map one function over the functor and then map the other function. Formally
\begin{verbatim}
fmap (g . h) = fmap g . fmap h
\end{verbatim}
This is the same as \verb|fmap (g . h) = fmap g (fmap h)|
\end{description}

If we can prove that a type satisfies these laws, we can make assumptions about how the the type will act. And we know that \verb|fmap| only maps the function over the functor. It will not change the structure or the context of the functor.

If we know, that a type satisfy the laws, we are able to deduce further properties for our own types. All type class instances in the standard library satisfy the laws \cite{yorgey}.

\begin{figure}
  \centering
\begin{verbatim}
fmap id = id
fmap (g . h) = fmap g . fmap h
\end{verbatim}
  \caption{The Functor laws}
  \label{fig:functorlaws}
\end{figure}

\subsection{Applicative Functor}
\label{sec:applicatives}

The \verb|Applicative| type class encapsulates the following idea. What if you have a function wrapped in a \verb|Functor| (e.g \verb|Maybe (Int -> Int -> Int)|) and you want to apply the function to another functor. 

The \verb|Applicative| type class is defined as follows.
\begin{verbatim}
class (Functor f) => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
\end{verbatim}

Applicatives are enhanced functors. They are able to map a function encapsulatet in a functor over another functor.

\subsection{Monoid}
\label{sec:monoid}

Some types, let's say \verb|a|, have a binary function with the type declaration \verb|a -> a -> a|. 

The type \verb|a| has a value that serves as identity for the given function. For example 1 is the identity for the multiplication. Multiplicaiton with an other numer $x$ results always in $x$.

Several value of type \verb|a| can always be reduces to a single value. It doesn't matter in which order we apply the function, the result is always the same. This is called associativity.

If type \verb|a| has this behavior, it's a monoid and it can be an instance of the \verb|Monoid| type class.

The \verb|Monoid| type class is define as follows:
\begin{verbatim}
class Monoid m where
    mempty :: m
    mappend :: m -> m -> m
    mconcat :: [m] -> m
    mconcat = foldr mappend mempty
\end{verbatim}

The \verb|Monoid| type class is define in \verb|Data.Monoid| \cite{monoid}. 

From the type class definition we see that concrete type can be made instances of \verb|Monoid|. 

\verb|mempty| return the identity value. The binary function is \verb|mappend|. It takes to values of the same type and returns another value of that type. \verb|mconcat| takes a list of monoids and reduces them \verb|mappend| to a single value, applying mappend. It has a default implementation.

When making monoid instances, we need to make sure that \verb|mempty| acts like the identity with respect to the \verb|mappend| function and \verb|mappend| must be assocative. There are three monoid laws

\begin{enumerate}
\item \verb|mappend mempty x = x|
\item \verb|mappend x mempty = x|
\item \verb|(x `mappend y) `mappend z = x `mappend (y `mappend z)|
\end{enumerate}

The following Haskell types are \verb|Monoid| instances
\begin{description}
\item[List] The empty list \verb|[]| and \verb|++| (concatenation) form a monoid.
\item[Product and Sum] Numers can be monoid with respect to multiplication or addidion. There are two monoid instances for \verb|Num|.
\item[Maybe] Can also be an instance of \verb|Monoid|.
\end{description}

An interesting property of the \verb|Applicative| type class with respect to the monoid type class is, if \verb|f| is an \verb|Applicative| and \verb|m| is a \verb|Monoid|, \verb|f b| is also a \verb|Monoid|. This is because we can make an \verb|Applicative| with the given property an instance of \verb|Monoid|.
\begin{program}
\begin{verbatim}
instance (Applicative f, Monoid b) => Monoid (f b) where
    mempty = pure mempty

    mappend = liftA2 mappend
\end{verbatim}
\label{lst:applicative2monoid}
\end{program}


As \verb|f| is an applicative, it implements \verb|pure|. The \verb|mempty| function returns the identity value of \verb|b| in a default context. \verb|liftA2| encapsulates the \verb|mappend| function in a applicative functor.

\section{Equational Reasoning}
\label{sec:equationalreasoning}

Some programmers care about the correctness of their software. It's hard to write a correct program at the first attempt. 
Hence, verification of a program improves the reliability of the software. Verification is process of checking if the software does the specification demands. This means that the specification is required. In the case of implementing the type classes of section \ref{sec:typeclasses}, the specification is defined in form of laws. The following section will describe the verification method equational reasoning. We will use equational reason in section \ref{sec:example} to show that the monoid laws hold for a given type.

There are several ways to check the behavior of a program. 
We will describe the difference with a simple example.
If we apply \verb|reverse| to times on the same list \verb|xs| we get back the original list \verb|xs|. \verb|reverse| is the inverse of \verb|reverse|. 

\begin{equation}
  \label{eq:reverse_prop}
\text{reverse} (\text{reverse} xs) == xs  
\end{equation}
This Boolean expression formulates a desired property. 

\begin{description}
\item[Testing] Run the program with selected input and check if it behaves as expected. Listing \ref{lst:testfunction} gives a test function of the property \ref{eq:reverse_prop} for the input \verb|[1,2,3]|.
  \label{fig:test}
\begin{program}
\begin{verbatim}
input = [1,2,3]

test_reverse :: [Int] -> Bool
test_reverse xs = reverse (reverse xs) == xs
\end{verbatim}
\caption{Test-Function}
\label{lst:testfunction}
\end{program}

In order to check if the property \ref{eq:reverse_prop} for the given input holds, we have to run the program.
 An advantage of this method is, that the programmer hasn't to define general properties. It's easier to think about a concrete input and the corresponding output.

\item[Property-based testing] The input for the test program is generated randomly. The test are executed by a tool (e.g. Quickcheck)
\item[Proof] A Proof can show that a property holds in all circumstances. With the definition of the function \verb|reverse| it's possible to proof that property \ref{eq:reverse_prop} always holds. 
\end{description}

\begin{figure}
  \centering
     \includegraphics[width=0.9\textwidth]{comp}
  \caption{Comparison of test, property-based-testing and proof}
  \label{fig:property_validation}
\end{figure}

Equational reasoning isn't a method only used in programming. Equational reasoning is the process of substituting expressions. With equational reasoning we are able to show that certain properties hold.
For example, it's possible to show that

\begin{equation}
  \label{eq:sum}
  (x+a)(x+b) = x^2 + (a+b)x+ab
\end{equation}

is true. To show the equality we have to only have to substitute the expression on the left-hand side with the help of the basic algebraic properties of numbers (commutative, associative, distributive) \cite{hutton}.

A function definition in Haskell means that we can substitute the left-hand side. Hence, we can use reasoning about a Haskell program in the same way, we reason about mathematical expressions. With equational reasoning it's possible to deduce properties from definitions.

For example, it's possible to show that 
\begin{verbatim}
length [x] == 1
\end{verbatim}
no matter what \verb|x| is.

This article will only describe proofs with programs, which halts. An evaluation can go on forever.
\begin{verbatim}
f x = 1 + f x
\end{verbatim}

The value of the expression is undefined. The proofs in this article hold only for defined expressions and finite lists..

Equational reasoning is use-full because
\begin{itemize}
\item it allows to verify properties of a program.
\item can be used to eliminate expensive function call while preserving behavior
\end{itemize}

\subsection{Proof by structural induction}
\label{sec:induction}

The technique proof by induction is often used to reason about programs that involve recursion. The principle of induction states that it is sufficient to prove a property $p$ for the base case and that $p$ is preserved by the inductive case.

Proof by induction is similar to write a recursive function. Recursive functions use a base case (e.g. \verb|[]|, 0). 
If we use structural induction we proof the base case.

A recursive function definition we define \verb|f (x:xs)| and use \verb|f x| in the right-hand side. In the proof we show that $p(n+1)$ with the assumption $p(n)$.

The pattern for structural induction for proofing a property can be use for list or algebraic data types with a recursive constructor (e.g. Tree).

We use induction to prove the following property
\begin{equation}
  \label{eq:lengthprop}
  \text{length (xs ++ ys)} = \text{(length xs) ++ (length ys)}
\end{equation}

The Prelude functions \verb|length| and \verb|(++)| are defined as follows:
\begin{program}
\begin{verbatim}
length [] = 0
length (x:xs) = 1 + length 
\end{verbatim}
\caption{Definition length function}
\label{lst:lengthdefinition}  
\end{program}

\begin{program}
\begin{verbatim}
[] ++ xs = xs
(x:xs) ++ ys = x:(xs++ys)
\end{verbatim}
\caption{Definition: ++ - function}
\label{lst:catdefinition}  
\end{program}

First we have to show that property \ref{eq:lengthprop} holds for the base case. The base case, in this example, are the arguments \verb|[]| and a arbitrary list for \verb|ys|. It isn't necessary to replace \verb|ys| because, the definition of \verb|++| uses recursion over \verb|xs|. \verb|ys| will always be the same list.
In order to check if property \ref{eq:lengthprop} holds for the base case, we replace \verb|xs| with  \verb|[]|, leading to

\begin{program}
\begin{verbatim}
length ([] ++ ys) = length [] + length ys
\end{verbatim}
\caption{Base case}
\label{lst:equality1}
\end{program}

We will evaluate the expression on the left-hand side and the right and side separately.

The left-hand side evaluates to
\begin{program}
\begin{verbatim}
length ([] ++ ys) -- apply ++
length ys
\end{verbatim}
\end{program}

The right-hand side evaluates to 
\begin{program}
\begin{verbatim}
length [] + length ys     -- apply length []
0 + length ys
length ys
\end{verbatim}
\end{program}

Both sides of the function definition in Listing \ref{lst:equality1} are equal. Hence, property \ref{eq:lengthprop} holds for the empty list, our base case.

Now we have to prove the induction step. We have to prove that
\begin{equation}
  \label{eq:induction}
    \text{length ((x:xs) ++ ys)} = \text{(length (x:xs)) ++ (length ys)}
\end{equation}

with the assumption (induction hypothesis)
\begin{equation}
  \label{eq:induction_hypothesis}
      \text{length (xs ++ ys)} = \text{(length xs) ++ (length ys)}
\end{equation}

Again, we evaluate the the left hand side of equation \ref{eq:induction}.

\begin{program}
\begin{verbatim}
length ((x:xs) ++ ys)}     --apply definition of ++
length (x:(xs ++ ys))      --apply definition of length
1 + length (xs ++ ys)      --use induction hypothesis
1 + length xs + length ys
\end{verbatim}
\end{program}

If we evaluate the right-hand side of the induction step in equation  \ref{eq:induction} we get:
\begin{program}
\begin{verbatim}
length (x:xs) + length ys    -- apply definition of length
1 + length xs + length ys
\end{verbatim}
\end{program}

The last listing shows, that the equation \ref{eq:induction} follows from the induction hypothesis in equation \ref{eq:induction_hypothesis}. This completes the induction step and therefore the proof itself.

\subsection{Example proof for Monoid Laws}
\label{sec:example}

The following example is taken from a blogpost of Gabriel Gonzales \cite{gonzales14}. 

Suppose we want to build a plugin system, that uses monoids to add additional functionality to system. If we can prove that the plugins satisfy the monoid laws, we can combine them, using the monoid function \verb|<>| and we can apply them without concerning about the order of evaluation. In addition they will behave as expected. 

Listing \ref{lst:plugin} show use of the plugin. The \verb|logto| function is a plugin. The program will read a character \verb|c| from the command line and apply the given plugin to \verb|c|.

\begin{program}
\begin{verbatim}
main = do
    handleChar <- logto
    c <- getChar
    handleChar c
\end{verbatim}
\label{lst:plugin}
\caption{main for plugin system}
\end{program}

The \verb|logTo| function is shown in Listing \ref{lst:logto}. Its of type \verb|IO(Char->IO())|. 

\begin{program}
\begin{verbatim}
logTo :: IO ( Char -> IO ())
logTo = do
    handle <- openFile "log.txt" WriteMode
    return (hPutChar handle)
\end{verbatim}
\label{lst:logto}
\caption{main for plugin system}
\end{program}

The plugins are of type \verb|IO ( Char -> IO ())|. We have to prove the monoid laws from section \ref{sec:monoid} for the type \verb|IO ( Char -> IO ())|.
As show in listing \ref{lst:applicative2monoid}, applicative can be a monoid if the encapsulated type is a monoid. To prove that \verb|IO ( Char -> IO ())| is a monoid \verb|IO| has to be an applicative and \verb|Char -> IO ()| has to be a monoid.

We can implement a monoid instance for the type \verb|a -> b| as follows:
\begin{verbatim}
instance Monoid b => Monoid (a -> b) where
    mempty = pure mempty

    mappend = liftA2 mappend
\end{verbatim}

With this implementation the type \verb|b| of \verb|a -> b| has also to be a monoid. In our example that is the type \verb|IO ()|. The standard library provides a monoid instance for \verb|()|. In this article we will assume that the implemention of the standard library satisfies the monoid laws.

To prove that \verb|IO ()| is an Monoid, we refer again to the monoid implemenation of listing \ref{lst:applicative2monoid}.

To prove the monoid laws for the type \verb|IO ( Char -> IO ())| we use a property of the \verb|Applicative| type class .

\begin{verbatim}
instance Applicative IO where
    pure = return

    x <*> y = do
        f <- x
        a <- y
        return (f a)
\end{verbatim}

\section{Pipes: A real world example}
\label{sec:pipes}

Pipes is a streaming library for Haskell. It was build with the following requirements \cite{gonzales13}.
\begin{description}
\item[Effects] Streams has to be effectful
\item[Streaming] Processing in constant memory
\item[Composability] Modules have to be composable
\end{description}

Pipes uses the type class \verb|Category| too keep the API simple and easy to use.

This article will descipe a part of the library with an example.

First we need a input stream, that emits values. Input streams are have the type 
\verb|Producer a m ()|.
Listing \ref{lst:simpleproducer} show a simple Producer. It emits the integers 1,2 and 3. It is also possible to create producers for effectful streams. We use the simple producer from Listing \ref{lst:simpleproducer} for simplicity reasons.

\begin{program}
\begin{verbatim}
produceints123 :: Producer Int IO ()
produceints123 = each [1,2,3]
\end{verbatim}
\caption{Simple Producer}
\label{lst:simpleproducer}
\end{program}

Pipes provide the function \verb|for| to consume a producer. 
\verb|for| \verb|producer| \verb|body| loops over the \verb|producer| and applies a the transformation defined in \verb|body| to every element yielded by the producer. If the body is of type \verb|Effect| it return an \verb|Effect|. If body is of type \verb|Producer| a \verb|Producer| is returned. The type declaration of \verb|for| 
\begin{program}
\begin{verbatim}
for::Monad m=>
Producer b m r
-> (b -> Producer c m ())
-> Producer c m r
\end{verbatim}
\caption{type of for}
\end{program}

A value for the body, could be function, that takes \verb|Int| and returns producer \verb|Producer a IO ()|. Hence the type declarion is \verb|Int -> Producer a IO ()|. We implement a body, that prints the integers to the standard input (strictly speaking this value is an effect of type \verb|Effect Int ()|. But \verb|Effect Int ()| is of type \verb|Producer Int IO () |).

\begin{program}
\begin{verbatim}
print2stdout:: Int -> Effect IO ()
print2stdout x = (lift . putStrLn . show ) x
\end{verbatim}
\caption{Definition of an effect, that prints to stdout}
\label{lst:stdouteffect}
\end{program}

With the producer and the body we can define a \verb|Effect IO ()|
\begin{verbatim}
effect :: Effect IO ()
effect = for produceints123 print2stdout
\end{verbatim}

Because the \verb|body| and of \verb|for| can be of type \verb|a -> Producer|, and the type of the return value is \verb|Producer|, it's possible to interleave several Producers.

If we want to duplicate all element we write another body
\begin{verbatim}
duplicate :: Int -> Producer Int IO ()
duplicate x = yield x >> yield x 
\end{verbatim}

We use \verb|for| to create a another producer. \verb|composed_producer| is a composition of \verb|produceints123| and \verb|duplicate|.
\begin{verbatim}
composed_producer :: Producer Int IO ()
composed_producer = for produceints123 duplicate
\end{verbatim}

To compose \verb|composed_producer| with our \verb|print2stdout| effect, we apply the \verb|for| function

\begin{verbatim}
effect2 :: Effect IO ()
effect2 = for composed_producer print2stdout
\end{verbatim}

In order to compose producers, the pipe library provides the \verb|~>| function. \verb|~>| is defined as follows:
\begin{verbatim}
(f ~> g) x = for (f x) g
\end{verbatim}

Hence we can write compose a body for \verb|for| like this:
\begin{verbatim}
composed_with_yield :: Int -> Effect IO ()
composed_with_yield = duplicate ~> print2stdout
\end{verbatim}

Gabriel Gonzales proved that the \verb|~>| operator is associativ. It has the associativity property.

\begin{verbatim}
 -- Associativity
 (f ~> g) ~> h = f ~> (g ~> h)
\end{verbatim}

Because the \verb|~>| operator is associativ, it doesnt matter in witch order the body is composed. The expected behavior is defined in term of cateory laws. It's possible to prove that the specified laws hold.

\section{Function composition}

\label{sec:functioncomposition}

Function composition in mathematics is defined as

\begin{equation}
  \label{eq:functioncomposition}
  (f \circ g)(x) = f(g(x))
\end{equation}

Haskell functions can be compose with the \verb|.| function.

\begin{figure}
  \centering
\begin{verbatim}
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \x -> f (g x)
\end{verbatim}
  \caption{. function}
  \label{fig:compositionfunction}
\end{figure}

Function composition allows us to create a function by composing it with many small functions. 

Functions in Haskell form a category in category theory. They satisfy the category laws.
\begin{description}
\item[Associativity law] 
\item[Left/Right Identity law] 
\end{description}

\bibliographystyle{plain}
\bibliography{a}
\end{document}