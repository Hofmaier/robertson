\newglossaryentry{verification}
{
name=verification,
description={Verification is the evaluation of whether a system complies with a specification}
}

\newglossaryentry{referential_transparency}
{
name={referential transparency},
description={An expression is said to be referential transparent if it can be replaced with its value without changing the behavior of a program.}
}

\newglossaryentry{adhoc_polymorphism}
{
name={ad hoc polymorphism},
description={Ad hoc polymorphism is also known as function overloading or operator overloading. Polymorphic functions can be applied to arguments of different types, because a polymorphic function can denote a number of distinct implementations depending on the type of the arguments to which it is applied}
}

\newglossaryentry{typeclass}
{
name={type class},
description={ A type class is a type system construct that supports ad hoc polymorphism. This is achieved by adding constraints to type variables in parametrically polymorphic types},
plural={type classes}
}
\newglossaryentry{typesignature}
{
name={type signature declaration},
description={A type signature declaration tells, what type a Haskell variable has},
plural={type signature declarations}
}

\newglossaryentry{monoid}
{
name={monoid},
description={A monoid is an algebraic structure with single associatve binary operation. they are semigroups with identity}
plural={monoids}
}

\newglossaryentry{function-definition}
{
name={function definition},
description={ In Haskell a function definition is an equation. The left-hand side is the function name and it's arguments. The right-hand side is contains the expression of the function body},
plural={function definitions}
}

\newglossaryentry{associativity}
{
name={associativity},
description={Within an expression containing two or more occurrences in a row of the same associative operator, the order in which the operations are performed does not matter as long as the sequence of the operands is not changed. That is, rearranging the parentheses in such an expression will not change its value}
}

\newglossaryentry{distributive_law}
{
name={distributive law},
description={Multiplying a number by a sum of numbers is the same as doing each multiplication separately}
}

\newglossaryentry{commutative_law}
{
name={commutative law},
description={Changing the order of two factors, does not change the product, for example}
}

\newglossaryentry{symbolic_eval}
{
name={symbolic evaluation},
description={Symbolic evaluation is a means of analyzing a program by assuming symbolic values for inputs rather than obtaining actual inputs as normal execution of the program would. It thus arrives at expressions in terms of those symbols for expressions and variables in the program, and constraints in terms of those symbols for the possible outcomes of each conditional branch}
}

