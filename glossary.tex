\newglossaryentry{verification}
{
name=verification,
description={the evaluation of whether a system complies with a specification}
}

\newglossaryentry{referential_transparency}
{
name={referential transparency},
description={an expression is said to be referential transparent if it can be replaced with its value without changing the behavior of a program.}
}

\newglossaryentry{adhoc_polymorphism}
{
name={ad hoc polymorphism},
description={also known as function overloading or operator overloading. Polymorphic functions can be applied to arguments of different types, because a polymorphic function can denote a number of distinct implementations depending on the type of the arguments to which it is applied.}
}

\newglossaryentry{typeclass}
{
name={type class},
description={ a type class is a type system construct that supports ad hoc polymorphism. This is achieved by adding constraints to type variables in parametrically polymorphic types.},
plural={type classes}
}
\newglossaryentry{typesignature}
{
name={type signature declaration},
description={a type signature declaration tells, what type a Haskell variable has.},
plural={type signature declarations}
}

\newglossaryentry{monoid}
{
name={monoid},
description={a monoid is an algebraic structure with single associatve binary operation. they are semigroups with identity.}
}

\newglossaryentry{function-definition}
{
name={function definition},
description={ In Haskell a function definition is an equation. The left-hand side is the function name and it's arguments. The right-hand side is contains the expression of the function body.},
plural={function definitions}
}

\newglossaryentry{associativity}
{
name={associativity},
description={Within an expression containing two or more occurrences in a row of the same associative operator, the order in which the operations are performed does not matter as long as the sequence of the operands is not changed. That is, rearranging the parentheses in such an expression will not change its value.}
}

